#!/usr/local/bin/csi -s
(import (chicken format)
        (chicken io)
        (list-comprehensions)
        (srfi 1)
        (srfi 4)
        (srfi 69))
(declare (fixnum-arithmetic) (block))

(define (coord= a b) (equal? a b))
(define (make-coord x y z w) (s8vector x y z w))
(define cube-copy hash-table-copy)
(define cube-for-each hash-table-walk)
(define cube-coords hash-table-keys)
(define (make-cube) (make-hash-table coord= hash))
(define cube-set! hash-table-set!)
(define (cube-ref cube coord) (hash-table-ref/default cube coord #\.))
(define cube-fold hash-table-fold)

(define (read-cube-slice #!optional (z 0) (port (current-input-port)))
  (let loop ((line (read-line port))
             (y 0)
             (cube (make-cube)))
    (if (eof-object? line)
        cube
        (do ((x 0 (+ 1 x)))
            ((= x (string-length line)) (loop (read-line port) (+ y 1) cube))
          (cube-set! cube (make-coord x y z 0) (string-ref line x))))))

(define (x-coord coord) (s8vector-ref coord 0))
(define (y-coord coord) (s8vector-ref coord 1))
(define (z-coord coord) (s8vector-ref coord 2))
(define (w-coord coord) (s8vector-ref coord 3))
(define (coord< a b)
  (and (< (x-coord a) (x-coord b))
       (< (y-coord a) (y-coord b))
       (< (z-coord a) (z-coord b))
       (< (w-coord a) (w-coord b))))
(define (active? cube coord)
  (char=? (cube-ref cube coord) #\#))
(define (set-active! cube coord)
  (cube-set! cube coord #\#))
(define (set-inactive! cube coord)
  (cube-set! cube coord #\.))
(define (count-active cube)
  (cube-fold cube (lambda (_ point total) (+ total (if (char=? point #\#) 1 0))) 0))

(define (neighbors-of coord)
  (delete! coord
           (collect (make-coord x y z 0)
                    (x (list (- (x-coord coord) 1) (x-coord coord) (+ (x-coord coord) 1)))
                    (y (list (- (y-coord coord) 1) (y-coord coord) (+ (y-coord coord) 1)))
                    (z (list (- (z-coord coord) 1) (z-coord coord) (+ (z-coord coord) 1))))
           coord=))

(define (neighbors-of-with-w coord)
  (delete! coord
           (collect (make-coord x y z w)
                    (x (list (- (x-coord coord) 1) (x-coord coord) (+ (x-coord coord) 1)))
                    (y (list (- (y-coord coord) 1) (y-coord coord) (+ (y-coord coord) 1)))
                    (z (list (- (z-coord coord) 1) (z-coord coord) (+ (z-coord coord) 1)))
                    (w (list (- (w-coord coord) 1) (w-coord coord) (+ (w-coord coord) 1))))
           coord=))

(define (count-active-neighbors cube coord #!optional with-w)
  (let ((neighbors-fun (if with-w neighbors-of-with-w neighbors-of)))
    (count (cut active? cube <>) (neighbors-fun coord))))

(define (toggle! newcube oldcube coord with-w)
  (let ((c (count-active-neighbors oldcube coord with-w))
        (a (active? oldcube coord)))
    (cond
     (a
      (if (or (= c 2) (= c 3))
          (set-active! newcube coord)
          (set-inactive! newcube coord)))
     ((and (not a) (= c 3))
      (set-active! newcube coord)))))

(define (cycle-cube oldcube with-w)
  (let ((newcube (make-cube))
        (neighbors-fun (if with-w neighbors-of-with-w neighbors-of))
        (coords (make-cube)))
    (cube-for-each oldcube (lambda (coord _)
                             (cube-set! coords coord #t)
                             (for-each (cut cube-set! coords <> #t)
                                       (neighbors-fun coord))))
    (cube-for-each coords (lambda (coord _) (toggle! newcube oldcube coord with-w)))
    newcube))

(define (run-n-cycles cube n #!optional with-w)
  (do ((cube cube (cycle-cube cube with-w))
       (m 0 (+ m 1)))
      ((= m n) cube)))

(define (solve1 cube)
  (count-active (run-n-cycles cube 6)))
(define (solve2 cube)
  (count-active (run-n-cycles cube 6 #t)))

(define input (read-cube-slice))
(printf "Part 1: ~A~%" (solve1 input))
(printf "Part 2: ~A~%" (solve2 input))
