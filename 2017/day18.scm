(require-extension srfi-1)
(require-extension srfi-69)
(require-extension irregex)
(require-extension format)

(define (get-value registers x)
  (if (char? x)
      (hash-table-ref/default registers x 0)
      x))

(define (parse-arg a)
  (if (and (= (string-length a) 1) (char-lower-case? (string-ref a 0)))
      (string-ref a 0)
      (string->number a)))

(define last-frequency 0)
(define prog1-send-count 0)
(define pc 0)
(define (snd x registers writer progn)
  (let ((freq (get-value registers x)))
    (if (queue? writer)
        (begin
          (when (= progn 1)
                (set! prog1-send-count (+ prog1-send-count 1)))
          (queue-add! writer freq))
        (set! last-frequency freq))
    1))
(define (set registers x y)
  (hash-table-set! registers x (get-value registers y))
  1)
(define (add registers x y)
  (hash-table-set! registers x (+ (get-value registers x) (get-value registers y)))
  1)
(define (mul registers x y)
  (hash-table-set! registers x (* (get-value registers x) (get-value registers y)))
  1)
(define (instrmod registers x y)
  (hash-table-set! registers x (remainder (get-value registers x) (get-value registers y)))
  1)
(define (rcv x registers reader)
  (let ((v (get-value registers x)))
    (if (queue? reader)
        (if (queue-empty? reader)
            0
            (begin
              (hash-table-set! registers x (queue-remove! reader))
              1))
        (begin
          (when (not (= v 0))
                (abort last-frequency))
          1))))
(define (jgz registers x y)
  (let ((valx (get-value registers x))
        (valy (get-value registers y)))
    (if (> valx 0)
        valy
        1)))

(define (compile-input cmds)
  (let ((snd-re (string->irregex "^snd ([a-z])$"))
        (set-re (string->irregex "^set ([a-z]) (-?\\d+|[a-z])$"))
        (add-re (string->irregex "^add ([a-z]) (-?\\d+|[a-z])$"))
        (mul-re (string->irregex "^mul ([a-z]) (-?\\d+|[a-z])$"))
        (mod-re (string->irregex "^mod ([a-z]) (-?\\d+|[a-z])$"))
        (rcv-re (string->irregex "^rcv ([a-z])$"))
        (jgz-re (string->irregex "^jgz (-?\\d+|[a-z]) (-?\\d+|[a-z])$")))
    (list->vector
     (map (lambda (instr)
            (cond
             ((irregex-match snd-re instr) =>
              (lambda (bits)
                (let ((x (parse-arg (irregex-match-substring bits 1))))
                  (lambda (r q1 q2 n) (snd x r q2 n)))))
             ((irregex-match set-re instr) =>
              (lambda (bits)
                (let ((x (parse-arg (irregex-match-substring bits 1)))
                      (y (parse-arg (irregex-match-substring bits 2))))
                  (lambda (r q1 q2 n) (set r x y)))))
             ((irregex-match add-re instr) =>
              (lambda (bits)
                (let ((x (parse-arg (irregex-match-substring bits 1)))
                      (y (parse-arg (irregex-match-substring bits 2))))
                  (lambda (r q1 q2 n) (add r x y)))))
             ((irregex-match mul-re instr) =>
              (lambda (bits)
                (let ((x (parse-arg (irregex-match-substring bits 1)))
                      (y (parse-arg (irregex-match-substring bits 2))))
                  (lambda (r q1 q2 n) (mul r x y)))))
             ((irregex-match mod-re instr) =>
              (lambda (bits)
                (let ((x (parse-arg (irregex-match-substring bits 1)))
                      (y (parse-arg (irregex-match-substring bits 2))))
                  (lambda (r q1 q2 n) (instrmod r x y)))))
             ((irregex-match rcv-re instr) =>
              (lambda (bits)
                (let ((x (parse-arg (irregex-match-substring bits 1))))
                  (lambda (r q1 q2 n) (rcv x r q1)))))
             ((irregex-match jgz-re instr) =>
              (lambda (bits)
                (let ((x (parse-arg (irregex-match-substring bits 1)))
                      (y (parse-arg (irregex-match-substring bits 2))))
                  (lambda (r q1 q2 n) (jgz r x y)))))
             (else
              (error "Unknown instruction" instr))))
          cmds))))

(define program (compile-input (read-lines)))
(define opcount (vector-length program))

(call/cc
 (lambda (quit)
   (with-exception-handler
    (lambda (val)
      (format #t "Part 1: ~A~%" val)
      (quit '()))
    (lambda ()
      (let ((registers (make-hash-table test: char=? hash: (lambda (c b) (char->integer c)))))
        (let loop ((pc 0))
          (if (or (< pc 0) (>= pc opcount))
              (display "Program terminated.\n")
              (loop (+ pc ((vector-ref program pc) registers #t #t 0))))))))))

(define registers1 (make-hash-table test: char=? hash: (lambda (c b) (char->integer c))))
(hash-table-set! registers1 #\p 0)
(define queue1 (make-queue))
(define registers2 (make-hash-table test: char=? hash: (lambda (c b) (char->integer c))))
(hash-table-set! registers2 #\p 1)
(define queue2 (make-queue))

(let loop ((pc1 0)
           (pc2 0)
           (stall-count 0))
  (if (or (< pc1 0) (< pc2 0) (>= pc1 opcount) (>= pc2 opcount))
      (display "Program terminated.\n")
      (let ((npc1 ((vector-ref program pc1) registers1 queue1 queue2 0))
            (npc2 ((vector-ref program pc2) registers2 queue2 queue1 1)))
        (if (and (= npc1 0) (= npc2 0))
            (if (> stall-count 4)
                (display "Programs deadlocked.\n")
                (loop pc1 pc2 (+ stall-count 1)))
            (loop (+ pc1 npc1) (+ pc2 npc2) 0)))))

(format #t "Part 2: ~A~%" prog1-send-count)

