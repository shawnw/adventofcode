(import (srfi 1) (srfi 8) (kawa regex))
(define (string->numlist str) (map string->number (regex-split "\\s+" str)))
(define (pair->values p) (values (car p) (cdr p)))
(define (minmax lst)
  (pair->values
   (fold (lambda (elem acc)
           (cons (if (< elem (car acc)) elem (car acc))
                 (if (> elem (cdr acc)) elem (cdr acc))))
         (cons (car lst) (car lst)) (cdr lst))))
(define (find-quotient lst)
  (call/cc
   (lambda (return)
     (for-each
      (lambda (elem1)
        (for-each (lambda (elem2)
                    (let*-values (((d1) (min elem1 elem2))
                                  ((d2) (max elem1 elem2))
                                  ((q r) (div-and-mod d2 d1)))
                      (if (= r 0)
                          (return q))))
                  (delete elem1 lst =)))
      lst)
     #f)))
(define (checksum-line lst)
  (let-values (((min max) (minmax lst))
               ((d) (find-quotient lst)))
    (values (- max min) d)))
(define (checksum port)
  (let loop ((total 0)
             (divs 0)
             (line (read-line port)))
    (if (eof-object? line)
        (values total divs)
        (receive (cksum div) (checksum-line (string->numlist line))
                 (loop (+ total cksum) (+ divs div) (read-line port))))))
(receive (part1 part2) (checksum (current-input-port))
         (format #t "Part 1: ~A~%Part 2: ~A~%" part1 part2))
