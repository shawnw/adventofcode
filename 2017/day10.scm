(import (srfi 1) (srfi 133) (knot-hash))

(define line (read-line))
(define pos 0)
(define skip 0)
(define (solve numbers lengths)
  (let* ((maxlen (vector-length numbers))
         (modadd (lambda args (remainder (apply + args) maxlen)))
         (moddecr (lambda (a) (if (= a 0) (- maxlen 1) (- a 1))))
         (reverse-section!
          (lambda (len)
            (let ((start pos)
                  (end (moddecr (modadd pos len)))
                  (endsteps (quotient len 2)))
              (do ((i start (modadd i 1))
                   (j end (moddecr j))
                   (steps 0 (+ steps 1)))
                  ((= steps endsteps))
                (vector-swap! numbers i j))
              (set! pos (modadd pos len skip))
              (set! skip (+ skip 1))))))
    (for-each reverse-section! lengths)
    (* (vector-ref numbers 0) (vector-ref numbers 1))))

(define (solve-part1 numlen lengths)
  (set! pos 0)
  (set! skip 0)
  (solve (list->vector (iota numlen)) lengths))

(format #t "Test 1: ~A~%" (solve-part1 5 '(3 4 1 5)))
(define input-part1 (map string->number (string-split line ",")))
(format #t "Part 1: ~A~%" (solve-part1 256 input-part1))

(format #t "Test 2: ~A~%" (knot-hash ""))
(format #t "Test 3: ~A~%" (knot-hash "AoC 2017"))
(format #t "Test 4: ~A~%" (knot-hash "1,2,3"))
(format #t "Test 5: ~A~%" (knot-hash "1,2,4"))
(format #t "Part 2: ~A~%" (knot-hash line))
 
